# Лабораторная №1

1. Создайте свой каталог в директории `/home/user/`  Все скрипты создавайте внутри этого каталога или его подкаталогов. (`mkdir lab1`)
2. Напишите скрипты, решающие следующие задачи:
    1. В параметрах при запуске скрипта передаются три целых числа. Вывести максимальное из них.
    2. Считывать строки с клавиатуры, пока не будет введена строка "q". После этого вывести последовательность считанных строк в виде одной строки.
    3. Создать текстовое меню с четырьмя пунктами. При вводе пользователем номера пункта меню происходит запуск редактора nano, редактора vi, браузера links (`sudo elinks` ) или выход из меню.
    4. Если скрипт запущен из домашнего директория, вывести на экран путь к домашнему директорию и выйти с кодом 0. В противном случае вывести сообщение об ошибке и выйти с кодом 1.
    5. Создать файл info.log, в который поместить все строки из файла `/var/log/dpkg.log`, третье поле в которых равно status.
    6. Создать install.log, в который вывести строки файла `/var/log/dpkg.log`, содержащие сообщения начале установки пакета (третье поле равно install), сообщение об окончании установки пакета (третье поле равно status, четвертое поле равно installed), сохранив время события, тип события (`STARTING`  для начала установки, `FINISHED`  для окончания) и название устанавливаемого пакета.
    7. Создать файл emails.lst, в который вывести через запятую все адреса электронной почты, встречающиеся во всех файлах директории `/etc`.
    8. Вывести список пользователей системы с указанием их UID, отсортировав по UID. Сведения о пользователей хранятся в файле `/etc/passwd`. В каждой строке этого файла первое поле – имя пользователя, третье поле – UID. Разделитель – двоеточие.
    9. Подсчитать общее количество строк в файлах, находящихся в директории `/var/log/` и имеющих расширение `log`.
    10. Вывести три наиболее часто встречающихся слова из `man` по команде `bash` длиной не менее четырех символов.


# Лабораторная №2

1. Перейдите в каталог `/home/user/lab-2`. Все скрипты и файлы для вывода результатов создавайте внутри этого каталога.
2. Напишите скрипты, решающие следующие задачи:
    1. Посчитать количество процессов, запущенных пользователем **user**, и вывести в файл получившееся число, а затем пары **PID:команда** для таких процессов.
    2. Вывести в файл список **PID** всех процессов, которые были запущены командами, расположенными в `/sbin/`.
    3. Вывести на экран **PID** процесса, запущенного последним (с последним временем запуска).
    4. Для всех зарегистрированных в данный момент в системе процессов определить среднее время непрерывного использования процессора (CPU_burst) и вывести в один файл строки **ProcessID=PID : Parent_ProcessID=PPID : Average_Running_Time=ART**. Значения **PPid** взять из файлов **status**, которые находятся в директориях с названиями, соответствующими **PID** процессов в `/proc`. Значения **ART** получить, разделив значение **sum_exec_runtime** на **nr_switches**, взятые из файлов **sched** в этих же директориях. Отсортировать эти строки по идентификаторам родительских процессов.
    5. В полученном на предыдущем шаге файле после каждой группы записей с одинаковым идентификатором родительского процесса вставить строку вида **Average_Running_Children_of_ParentID=N is M**, где **N** = **PPID**, а **M** – среднее, посчитанное из **ART** для всех процессов этого родителя.
    6. Используя псевдофайловую систему `/proc` найти процесс, которому выделено больше всего оперативной памяти. Сравнить результат с выводом команды `top`.
    7. Написать скрипт, определяющий три процесса, которые за 1 минуту, прошедшую с момента запуска скрипта, считали максимальное количество байт из устройства хранения данных. Скрипт должен выводить **PID**, строки запуска и объем считанных данных, разделенные двоеточием.


# Лабораторная №3

1. Создайте и однократно выполните скрипт (в этом скрипте нельзя использовать условный оператор и операторы проверки свойств и значений), который будет пытаться создать директорию **test** в домашней директории. Если создание директории пройдет успешно, скрипт выведет в файл **~/report** сообщение вида "**catalog test was created successfully**" и создаст в директории **test** файл с именем **Дата_Время_Запуска_Скрипта**. 
Затем независимо от результатов предыдущего шага скрипт должен опросить с помощью команды **ping** хост `www.net_nikogo.ru` и, если этот хост недоступен, дописать сообщение об ошибке в файл **`~/report`** 
Сообщение об ошибке должно начинаться с текущей **Дата_Время**, а затем содержать через пробел произвольный текст сообщения об ошибке.
2. Задайте еще один однократный запуск скрипта из пункта 1 через 2 минуты. Консоль после этого должна оставаться свободной. Выполнив отдельную команду организуйте слежение за файлом **`~/report`**  и выведите на консоль новые строки из этого файла, как только они появятся.
3. Задайте запуск скрипта из пункта 1 в каждую пятую минут каждого часа в день недели, в который вы будете выполнять работу.
4. Создайте три фоновых процесса, выполняющих одинаковый бесконечный цикл вычисления (например, перемножение двух чисел). 
После запуска процессов должна сохраниться возможность использовать виртуальную консоль, с которой их запустили. 
Используя команду **top**, проанализируйте процент использования ресурсов процессора этими процессами. 
Создайте скрипт, который будет в автоматическом режиме обеспечивать, чтобы тот процесс, который был запущен первым, использовал ресурс процессора не более чем на 10%. Послав сигнал, завершите работу процесса, запущенного третьим. 
Проверьте, что созданный скрипт по-прежнему удерживает потребление ресурсов процессора первым процессом в заданном диапазоне.
5. Создайте пару скриптов: генератор и обработчик. 
Процесс «Генератор» передает информацию процессу «Обработчик» с помощью именованного канала. 
Процесс «Обработчик» должен осуществлять следующую обработку переданных строк: если строка содержит единственный символ «**+**», то процесс обработчик переключает режим на «сложение» и ждет ввода численных данных. 
Если строка содержит единственный символ «*****», то обработчик переключает режим на «умножение» и ждет ввода численных данных. Если строка содержит целое число, то обработчик осуществляет текущую активную операцию (выбранный режим) над текущим значением вычисляемой переменной и считанным значением (например, складывает или перемножает результат предыдущего вычисления со считанным числом). 
При запуске скрипта режим устанавливается в «сложение», а вычисляемая переменная приравнивается к 1. 
В случае получения строки **QUIT** скрипт «Обработчик» выдает сообщение о плановой остановке и оба скрипта завершают работу. В случае получения любых других значений строки оба скрипта завершают работу с сообщением об ошибке входных данных.
Также создайте скрипт-оркестратор, создающий канал, запускающий оба скрипта, и удаляющий канал по завершению работы.
6. Создайте пару скриптов: генератор и обработчик. 
Процесс "Генератор" считывает с консоли строки в бесконечном цикле. Если считанная строка содержит единственный символ `+`, он посылает процессу "Обработчик" сигнал USR1. Если строка содержит единственный символ `*`, генератор посылает обработчику сигнал USR2. Если строка содержит слово `TERM`, генератор посылает обработчику сигнал SIGTERM и завершает свою работу. Другие значения входных строк игнорируются.
Обработчик добавляет 2 или умножает на 2 текущее значение обрабатываемого числа (начальное значение принять на единицу) в зависимости от полученного пользовательского сигнала и выводит результат на экран. Вычисление и вывод производятся один раз в секунду. Получив сигнал SIGTERM, "Обработчик" завершает свою работу, выведя сообщения о завершении работы по сигналу от другого процесса.
Создайте скрипт-оркестратор, который запускает оба скрипта: "Генератор" и "Обработчик".

# Лабораторная №4

## Скрипт `rmtrash`

1. Скрипту передается один параметр – имя файла в текущем каталоге вызова скрипта.
2. Скрипт проверяет, создан ли скрытый каталог **`trash`** в домашнем каталоге пользователя. Если он не создан – создает его.
3. После этого скрипт создает в этом каталоге жесткую ссылку на переданный файл с уникальным именем (например, присваивает каждой новой ссылке имя, соответствующее следующему натуральному числу) и удаляет файл в текущем каталоге.
4. Затем в скрытый файл **`trash.log`** в домашнем каталоге пользователя помещается запись, содержащая полный исходный путь к удаленному файлу и имя созданной жесткой ссылки.

## Скрипт `untrash`

1. Скрипту передается один параметр – имя файла, который нужно восстановить (без полного пути – только имя).
2. Скрипт по файлу **`trash.log`** должен найти все записи, содержащие в качестве имени файла переданный параметр, и выводить по одному на экран полные имена таких файлов с запросом подтверждения.
3. Если пользователь отвечает на подтверждение положительно, то предпринимается попытка восстановить файл по указанному полному пути (создать в соответствующем каталоге жесткую ссылку на файл из **`trash`** и удалить соответствующий файл из **`trash`**). Если каталога, указанного в полном пути к файлу, уже не существует, то файл восстанавливается в домашний каталог пользователя с выводом соответствующего сообщения. При невозможности создать жесткую ссылку, например, из-за конфликта имен, пользователю предлагается изменить имя восстанавливаемого файла.

## Скрипт `backup`

1. Скрипт создаст в **`/home/user/`** каталог с именем **`Backup-YYYY-MM-DD`**, где YYYY-MM-DD – дата запуска скрипта, если в **`/home/user/`** нет каталога с именем, соответствующим дате, отстоящей от текущей менее чем на 7 дней. Если в **`/home/user/`** уже есть «действующий» каталог резервного копирования (созданный не ранее 7 дней от даты запуска скрипта), то новый каталог не создается. Для определения текущей даты можно воспользоваться командой **`date`**.
2. Если новый каталог был создан, то скрипт скопирует в этот каталог все файлы из каталога **`/home/user/source/`** (для тестирования скрипта создайте такую директорию и набор файлов в ней). После этого скрипт выведет в режиме дополнения в файл **`/home/user/backup-report`** следующую информацию:
   - строка со сведениями о создании нового каталога с резервными копиями с указанием его имени и даты создания
   - список файлов из **`/home/user/source/`**, которые были скопированы в этот каталог
3. Если каталог не был создан (есть «действующий» каталог резервного копирования), то скрипт должен скопировать в него все файлы из **`/home/user/source/`** по следующим правилам:
   - если файла с таким именем в каталоге резервного копирования нет, то он копируется из **`/home/user/source`**
   - если файл с таким именем есть, то его размер сравнивается с размером одноименного файла в действующем каталоге резервного копирования
     - если размеры совпадают, файл не копируется
     - если размеры отличаются, то файл копируется c автоматическим созданием версионной копии

## Скрипт `upback`

1. Скрипт должен скопировать в каталог **`/home/user/restore/`** все файлы из актуального на данный момент каталога резервного копирования (имеющего в имени наиболее свежую дату), за исключением файлов с предыдущими версиями.



# Лабораторная №5

Проведите два виртуальных эксперимента в соответствии с требованиями и проанализируйте их результаты. В указаниях ниже описано, какие данные необходимо фиксировать в процессе проведения экспериментов.

Рекомендуется написать «следящие» скрипты и собирать данные, например, из вывода утилиты `top` ****автоматически с заданной периодичностью, например, 1 раз в секунду. Можно проводить эксперименты и фиксировать требуемые параметры и в ручном режиме, но в этом случае рекомендуется замедлить эксперимент, например, уменьшив размер добавляемой к массиву последовательности с 10 до 5 элементов.

## **Требования к проведению экспериментов и содержанию отчета**

Зафиксируйте в отчете данные о текущей конфигурации операционной системы в аспекте управления памятью:

- Общий объем оперативной памяти.
- Объем раздела подкачки.
- Размер страницы виртуальной памяти.
- Объем свободной физической памяти в ненагруженной системе.
- Объем свободного пространства в разделе подкачки в ненагруженной системе.

### **Эксперимент №1**

**Подготовительный этап:**

Создайте скрипт **`mem.bash`**, реализующий следующий сценарий:

- Скрипт выполняет бесконечный цикл.
- Перед началом выполнения цикла создается пустой массив и счетчик шагов, инициализированный нулем.
- На каждом шаге цикла в конец массива добавляется последовательность из 10 элементов, например, (1 2 3 4 5 6 7 8 9 10).
- Каждый 100000-ый шаг в файл **report.log** добавляется строка с текущим значением размера массива (перед запуском скрипта, файл обнуляется).

**Первый этап:**

> Задача – оценить изменения параметров, выводимых утилитой **top** в процессе работы созданного скрипта.
> 

*Ход эксперимента:*

- Запустите созданный скрипт **`mem.bash`**
- Дождитесь аварийной остановки процесса и вывода в консоль последних сообщений системного журнала.
- Зафиксируйте в отчете последнюю запись журнала - значения параметров, с которыми произошла аварийная остановка процесса. 
Также зафиксируйте значение в последней строке файла **`report.log`**
- Подготовьте две консоли.
    - В первой запустите утилиту `top`
    - Во второй запустите скрипт и переключитесь на первую консоль.
- Убедитесь, что в `top` появился запущенный скрипт. Наблюдайте за следующими значениями (и фиксируйте их изменения во времени в отчете)
    - значения параметров памяти системы (верхние две строки над основной таблицей)
    - значения параметров в строке таблицы, соответствующей работающему скрипту
    - изменения в верхних пяти процессах (как меняется состав и позиции этих процессов).

Проводите наблюдения и фиксируйте их в отчете до аварийной остановки процесса скрипта и его исчезновения из перечня процессов в `top`.

Посмотрите с помощью команды `dmesg **|** grep **"mem.bash"`**  последние две записи о скрипте в системном журнале и зафиксируйте их в отчете. Также зафиксируйте значение в последней строке файла **`report.log`**

**Второй этап:**

> Задача – оценить изменения параметров, выводимых утилитой `top` в процессе работы нескольких экземпляров созданного скрипта.
> 

*Ход эксперимента:*

- Создайте копию скрипта, созданного на предыдущем этапе, в файл **`mem2.bash`**
- Настройте её на запись в файл **`report2.log`**
- Создайте скрипт, который запустит немедленно друг за другом оба скрипта в фоновом режиме.
- Подготовьте две консоли.
    - В первой запустите утилиту `top`
    - Во второй запустите созданный перед этим скрипт и переключитесь на первую консоль.
- Убедитесь, что в `top` появились **`mem.bash`** и **`mem2.bash`**. Наблюдайте за следующими значениями (и фиксируйте их изменения во времени в отчете)
    - значения параметров памяти системы (верхние две строки над основной таблицей)
    - значения параметров в строке таблицы, соответствующей работающему скрипту
    - изменения в верхних пяти процессах (как меняется состав и позиции этих процессов).

Проводите наблюдения и фиксируйте их в отчете до аварийной остановки последнего из двух скриптов и их исчезновения из перечня процессов в **top**.

Посмотрите с помощью команды `dmesg **|** grep **"mem[2]* .bash"`**  последние записи о скриптах в системном журнале и зафиксируйте их в отчете. Также зафиксируйте значения в последних строках файлов **`report.log`** и **`report2.log`**

**Обработка результатов:**

Постройте графики изменения каждой из величин, за которыми производилось наблюдение на каждом из этапов. Объясните динамику изменения этих величин исходя из теоретических основ управления памятью в рамках страничной организации памяти с разделом подкачки. Объясните значения пороговых величин: размер массива, при котором произошла аварийная остановка процесса, параметры, зафиксированные в момент аварийной остановки системным журналом. Сформулируйте письменные выводы.

### **Эксперимент №2**

**Подготовительный этап:**

- Создайте копию скрипта **`mem.bash`** в файл **`newmem.bash`**
- Измените копию таким образом, чтобы она завершала работу, как только размер создаваемого массива превысит значение **N**, передаваемое в качестве параметра скрипту.
- Уберите запись данных в файл.

**Основной этап:**

> Задача – определить граничные значения потребления памяти, обеспечивающие безаварийную работу для регулярных процессов, запускающихся с заданной интенсивностью.
> 

*Ход эксперимента:*

- Создайте скрипт, который будет запускать **`newmem.bash`** каждую секунду, используя один и тот же параметр **N** так, что всего будет осуществлено **K** запусков.
    - Возьмите в качестве значения **N**, величину, в 10 раз меньшую, чем размер массива, при котором происходила аварийная остановка процесса в первом этапе предыдущего эксперимента.
    - Возьмите в качестве **K** значение 10.
- Убедитесь, что все **K** запусков успешно завершились, и в системном журнале нет записей об аварийной остановке **`newmem.bash`**
- Измените значение **K** на 30 и снова запустите скрипт. Объясните, почему ряд процессов завершился аварийно.
- Подберите такое максимальное значение **N**, чтобы при **K=30** не происходило аварийных завершений процессов.
- Укажите в отчете сформулированные выводы по этому эксперименту и найденное значение **N**.

